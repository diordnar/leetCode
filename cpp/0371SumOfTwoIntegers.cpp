#include <iostream>

using namespace std;
// 371. 两整数之和
// 利用位操作实现加法

// 首先看十进制是如何做的： 5+7=12，三步走

//     第一步：相加各位的值，不算进位，得到2。
//     第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。
//     第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。

// 同样我们可以用三步走的方式计算二进制值相加： 5---101，7---111

//     第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。
//     第二步：计算进位值，得到1010，相当于各位进行与操作得到101，再向左移一位得到1010，(101&111)<<1。
//     第三步重复上述两步，各位相加 010^1010=1000，进位值为100=(010 & 1010)<<1。
//     继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。
//     结束条件：进位为0，即a为最终的求和结果。

// 作者：phoenixfei
// 链接：https://leetcode-cn.com/problems/sum-of-two-integers/solution/li-yong-wei-cao-zuo-shi-xian-liang-shu-qiu-he-by-p/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

// C++位操作解法 为什么对负数也成立
// 借鉴大家的思路，再加上自己的理解过程，希望能对和我一样的新手的理解有所帮助

// 二进制计算中，
// 1+1=0(进位)
// 1+0=1(无进位)
// 0+1=1(无进位)
// 0+0=0(无进位)
// 我们可以将其拆成两个步骤，先进行位加(与异或运算相同，真值表 0 1 1 0)，再加上进位
// (与运算，真值表 1 0 0 0)

// 代码如下：

//     int getSum(int a, int b) {
//         while(b){
//             int carry = unsigned(a&b) << 1;
//             a ^= b;
//             b = carry;
//         }
//         return a;
//     }

// 进一步的理解：

// 关于carry：
// 进位为向前一位加，所以得到相应的进位值后需要再左移一位
// c++(或者说leetcode的c++编译器)中关于负数的移位要求很奇怪，我的理解是对应进位过程只考虑对应0或1，
// 不考虑正负，这点和下面的补码部分对应

// 为什么负数也成立：
// 首先是基础的补码知识
// 我们都知道计算机中负数的存储用补码，相应处理方法是，正数不变，负数由相应正数取反再加一得到，
// 那对负数进行这样的操作的原因是什么呢

// 以钟表为例，顺时针走3格和逆时针走9格表示的含义相同；同样，补码中负数的存储，就是在逆时针走，
// 只是此时表盘上不只有12格了而已
// int类占四个字节32位，第一位是符号位；按数学方式考虑，对正数a取反之后，得到2^32-1-a，再加上1，
// 正好得到2^32-a，-a此时表示为2^32-a。也就是说，表盘上一共有2^32格；
// 表盘的前一半，顺时针走得快，也就是大概2^31个正数，0到2^31，符号位为0；
// 表盘后一半，逆时针走得快，同样大概2^31个负数，(2^32-0) 到 (2^32-2^31) ，符号位为1；

// 补码的好处呢，就是减法此时可以换成加法的形式，举个例子，
// 4 - 5，变成了 4 + (-5)，按照上面的数学方式理解也就是 4 + (2^32-5) = 2^32-1，结果落在表盘的
// 后一半，还是负数，得到-1；

// 至于为什么这个方法负数同样适用，就得益于补码的这个特点，它消除了加法中的符号特性，计算机可以直接
// 对数进行二进制加，结果再利用补码存储。
// 上面的用异或和与操作一起模拟的，实现的就是二进制加法的过程；保证结果正确的，是补码本身。

// 作者：venelee
// 链接：https://leetcode-cn.com/problems/sum-of-two-integers/solution/cwei-cao-zuo-jie-fa-wei-shi-yao-dui-fu-shu-ye-chen/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
class Solution
{
public:
    int getSum(int a, int b)
    {
        while (b != 0)
        {
            int tmp = a ^ b;
            // [LeetCode] runtime error: left shift of negative value -2147483648
            b = static_cast<unsigned>(a & b) << 1; // << 的优先级大于 & 的优先级
            a = tmp;
        }

        return a;
    }
};

int main()
{
    int a = -1, b = 1;
    Solution slv;
    cout << slv.getSum(a, b) << endl;
    return 0;
}